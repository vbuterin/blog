

<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<style>
@media (prefers-color-scheme: dark) {
    body {
        background-color: #1c1c1c;
        color: white;
    }
    .markdown-body table tr {
        background-color: #1c1c1c;
    }
    .markdown-body table tr:nth-child(2n) {
        background-color: black;
    }
}
</style>



<link rel="alternate" type="application/rss+xml" href="../../../../feed.xml" title="STARKs, Part 3: Into the Weeds">



<link rel="stylesheet" type="text/css" href="../../../../css/common-vendor.b8ecfc406ac0b5f77a26.css">
<link rel="stylesheet" type="text/css" href="../../../../css/fretboard.f32f2a8d5293869f0195.css">
<link rel="stylesheet" type="text/css" href="../../../../css/pretty.0ae3265014f89d9850bf.css">
<link rel="stylesheet" type="text/css" href="../../../../css/pretty-vendor.83ac49e057c3eac4fce3.css">
<link rel="stylesheet" type="text/css" href="../../../../css/global.css">
<link rel="stylesheet" type="text/css" href="../../../../css/misc.css">

<script type="text/x-mathjax-config">
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\(', '\)']]
  },
  svg: {
    fontCache: 'global',
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="../../../../scripts/tex-svg.js">
</script>

<style>
</style>

<div id="doc" class="container-fluid markdown-body comment-enabled" data-hard-breaks="true">

<div id="color-mode-switch">
  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
  </svg>
  <input type="checkbox" id="switch" />
  <label for="switch">Dark Mode Toggle</label>
  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
  </svg>
</div>

<script type="text/javascript">
  // Update root html class to set CSS colors
  const toggleDarkMode = () => {
    const root = document.querySelector('html');
    root.classList.toggle('dark');
  }

  // Update local storage value for colorScheme
  const toggleColorScheme = () => {
    const colorScheme = localStorage.getItem('colorScheme');
    if (colorScheme === 'light') localStorage.setItem('colorScheme', 'dark');
    else localStorage.setItem('colorScheme', 'light');
  }

  // Set toggle input handler
  const toggle = document.querySelector('#color-mode-switch input[type="checkbox"]');
  if (toggle) toggle.onclick = () => {
    toggleDarkMode();
    toggleColorScheme();
  }

  // Check for color scheme on init
  const checkColorScheme = () => {
    const colorScheme = localStorage.getItem('colorScheme');
    // Default to light for first view
    if (colorScheme === null || colorScheme === undefined) localStorage.setItem('colorScheme', 'light');
    // If previously saved to dark, toggle switch and update colors
    if (colorScheme === 'dark') {
      toggle.checked = true;
      toggleDarkMode();
    }
  }
  checkColorScheme();
</script>

<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="STARKs, Part 3: Into the Weeds" />
<meta name="twitter:image" content="http://vitalik.eth.limo/images/icon.png" />


<br>
<h1 style="margin-bottom:7px"> STARKs, Part 3: Into the Weeds </h1>
<small style="float:left; color: #888"> 2018 Jul 21 </small>
<small style="float:right; color: #888"><a href="../../../../index.html">See all posts</a></small>
<br> <br> <br>
<title> STARKs, Part 3: Into the Weeds </title>

<p><em>Special thanks to Eli ben Sasson for his kind assistance, as
usual. Special thanks to Chih-Cheng Liang and Justin Drake for review,
and to Ben Fisch for suggesting the reverse MIMC technique for a VDF
(paper <a href="https://eprint.iacr.org/2018/601.pdf">here</a>)</em></p>
<p><em>Trigger warning: math and lots of python</em></p>
<style>
div.foo {
    color: white;
}
div.foo:hover {
    color: black;
}
</style>
<p>As a followup to <a
href="../../../2017/11/09/starks_part_1.html">Part 1</a> and <a
href="../../../2017/11/22/starks_part_2.html">Part 2</a> of this series,
this post will cover what it looks like to actually implement a STARK,
complete with an implementation in python. STARKs ("Scalable Transparent
ARgument of Knowledge" are a technique for creating a proof that <span
class="math inline">\(f(x)=y\)</span> where <span
class="math inline">\(f\)</span> may potentially take a very long time
to calculate, but where the proof can be verified very quickly. A STARK
is "doubly scalable": for a computation with <span
class="math inline">\(t\)</span> steps, it takes roughly <span
class="math inline">\(O(t \cdot \log{t})\)</span> steps to produce a
proof, which is likely optimal, and it takes ~<span
class="math inline">\(O(\log^2{t})\)</span> steps to verify, which for
even moderately large values of <span class="math inline">\(t\)</span>
is much faster than the original computation. STARKs can also have a
privacy-preserving "zero knowledge" property, though the use case we
will apply them to here, making verifiable delay functions, does not
require this property, so we do not need to worry about it.</p>
<p>First, some disclaimers:</p>
<ul>
<li>This code has not been thoroughly audited; soundness in production
use cases is not guaranteed</li>
<li>This code is very suboptimal (it's written in Python, what did you
expect)</li>
<li>STARKs "in real life" (ie. as implemented in Eli and co's production
implementations) tend to use binary fields and not prime fields for
application-specific efficiency reasons; however, they do stress in
their writings the prime field-based approach to STARKs described here
is legitimate and can be used</li>
<li>There is no "one true way" to do a STARK. It's a broad category of
cryptographic and mathematical constructs, with different setups optimal
for different applications and constant ongoing research to reduce
prover and verifier complexity and improve soundness.</li>
<li>This article absolutely expects you to know how modular arithmetic
and prime fields work, and be comfortable with the concepts of
polynomials, interpolation and evaluation. If you don't, go back to <a
href="../../../2017/11/22/starks_part_2.html">Part 2</a>, and also this
<a
href="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">earlier
post on quadratic arithmetic programs</a></li>
</ul>
<p>Now, let's get to it.</p>
<h3 id="mimc">MIMC</h3>
<p>Here is the function we'll be doing a STARK of:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mimc(inp, steps, round_constants):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(steps<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        inp <span class="op">=</span> (inp<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> round_constants[i <span class="op">%</span> <span class="bu">len</span>(round_constants)]) <span class="op">%</span> modulus</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;MIMC computed in </span><span class="sc">%.4f</span><span class="st"> sec&quot;</span> <span class="op">%</span> (time.time() <span class="op">-</span> start_time))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> inp</span></code></pre></div>
<p>We choose MIMC (see <a
href="https://eprint.iacr.org/2016/492.pdf">paper</a>) as the example
because it is both (i) simple to understand and (ii) interesting enough
to be useful in real life. The function can be viewed visually as
follows:</p>
<center>
<img src="../../../../images/starks-part-3-files/MIMC.png" class="padded" /><br>
<br> <small><i>Note: in many discussions of MIMC, you will typically see
XOR used instead of +; this is because MIMC is typically done over
binary fields, where addition <em>is</em> XOR; here we are doing it over
prime fields.</i></small>
</center>
<p><br></p>
<p>In our example, the round constants will be a relatively small list
(eg. 64 items) that gets cycled through over and over again (that is,
after <code>k[64]</code> it loops back to using <code>k[1]</code>).</p>
<p>MIMC with a very large number of rounds, as we're doing here, is
useful as a <em>verifiable delay function</em> - a function which is
difficult to compute, and particularly non-parallelizable to compute,
but relatively easy to verify. MIMC by itself achieves this property to
some extent because MIMC <em>can</em> be computed "backward" (recovering
the "input" from its corresponding "output"), but computing it backward
takes about 100 times longer to compute than the forward direction (and
neither direction can be significantly sped up by parallelization). So
you can think of computing the function in the backward direction as
being the act of "computing" the non-parallelizable proof of work, and
computing the function in the forward direction as being the process of
"verifying" it.</p>
<center>
<img src="../../../../images/starks-part-3-files/MIMC2.png" class="padded" /><br>
<br> <small><i><span class="math inline">\(x \rightarrow
x^{(2p-1)/3}\)</span> gives the inverse of <span class="math inline">\(x
\rightarrow x^3\)</span>; this is true because of
<a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem">Fermat's
Little Theorem</a>, a theorem that despite its supposed littleness is
arguably much more important to mathematics than Fermat's more famous
"Last Theorem".</i></small>
</center>
<p><br></p>
<p>What we will try to achieve here is to make verification much more
efficient by using a STARK - instead of the verifier having to run MIMC
in the forward direction themselves, the prover, after completing the
computation in the "backward direction", would compute a STARK of the
computation in the "forward direction", and the verifier would simply
verify the STARK. The hope is that the overhead of computing a STARK can
be less than the difference in speed running MIMC forwards relative to
backwards, so a prover's time would still be dominated by the initial
"backward" computation, and not the (highly parallelizable) STARK
computation. Verification of a STARK can be relatively fast (in our
python implementation, ~0.05-0.3 seconds), no matter how long the
original computation is.</p>
<p>All calculations are done modulo <span class="math inline">\(2^{256}
- 351 \cdot 2^{32} + 1\)</span>; we are using this prime field modulus
because it is the largest prime below <span
class="math inline">\(2^{256}\)</span> whose multiplicative group
contains an order <span class="math inline">\(2^{32}\)</span> subgroup
(that is, there's a number <span class="math inline">\(g\)</span> such
that successive powers of <span class="math inline">\(g\)</span> modulo
this prime loop around back to <span class="math inline">\(1\)</span>
after exactly <span class="math inline">\(2^{32}\)</span> cycles), and
which is of the form <span class="math inline">\(6k+5\)</span>. The
first property is necessary to make sure that our efficient versions of
the FFT and FRI algorithms can work, and the second ensures that MIMC
actually can be computed "backwards" (see the use of <span
class="math inline">\(x \rightarrow x^{(2p-1)/3}\)</span> above).</p>
<h3 id="prime-field-operations">Prime field operations</h3>
<p>We start off by building a convenience class that does prime field
operations, as well as operations with polynomials over prime fields.
The code is <a
href="https://github.com/ethereum/research/blob/master/mimc_stark/poly_utils.py">here</a>.
First some trivial bits:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PrimeField():</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, modulus):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Quick primality test</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="bu">pow</span>(<span class="dv">2</span>, modulus, modulus) <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.modulus <span class="op">=</span> modulus</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add(<span class="va">self</span>, x, y):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (x<span class="op">+</span>y) <span class="op">%</span> <span class="va">self</span>.modulus</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sub(<span class="va">self</span>, x, y):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (x<span class="op">-</span>y) <span class="op">%</span> <span class="va">self</span>.modulus</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> mul(<span class="va">self</span>, x, y):</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (x<span class="op">*</span>y) <span class="op">%</span> <span class="va">self</span>.modulus</span></code></pre></div>
<p>And the <a
href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Extended
Euclidean Algorithm</a> for computing modular inverses (the equivalent
of computing <span class="math inline">\(\frac{1}{x}\)</span> in a prime
field):</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Modular inverse using the extended Euclidean algorithm</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inv(<span class="va">self</span>, a):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    lm, hm <span class="op">=</span> <span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    low, high <span class="op">=</span> a <span class="op">%</span> <span class="va">self</span>.modulus, <span class="va">self</span>.modulus</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> low <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> high<span class="op">//</span>low</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        nm, new <span class="op">=</span> hm<span class="op">-</span>lm<span class="op">*</span>r, high<span class="op">-</span>low<span class="op">*</span>r</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        lm, low, hm, high <span class="op">=</span> nm, new, lm, low</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lm <span class="op">%</span> <span class="va">self</span>.modulus</span></code></pre></div>
<p>The above algorithm is relatively expensive; fortunately, for the
special case where we need to do many modular inverses, there's a simple
mathematical trick that allows us to compute many inverses, called <a
href="https://books.google.com/books?id=kGu4lTznRdgC&amp;pg=PA54&amp;lpg=PA54&amp;dq=montgomery+batch+inversion&amp;source=bl&amp;ots=tPJcPPOrCe&amp;sig=Z3p_6YYwYloRU-f1K-nnv2D8lGw&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjO8sumgJjcAhUDd6wKHWGNA9cQ6AEIRDAE#v=onepage&amp;q=montgomery%20batch%20inversion&amp;f=false">Montgomery
batch inversion</a>:</p>
<center>
<img src="../../../../images/starks-part-3-files/MultiInv.png" class="padded" /><br>
<br> <small><i>Using Montgomery batch inversion to compute modular
inverses. Inputs purple, outputs green, multiplication gates black; the
red square is the <b>only</b> modular inversion.</i></small>
</center>
<p><br></p>
<p>The code below implements this algorithm, with some slightly ugly
special case logic so that if there are zeroes in the set of what we are
inverting, it sets their inverse to 0 and moves along.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_inv(<span class="va">self</span>, values):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    partials <span class="op">=</span> [<span class="dv">1</span>]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(values)):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        partials.append(<span class="va">self</span>.mul(partials[<span class="op">-</span><span class="dv">1</span>], values[i] <span class="kw">or</span> <span class="dv">1</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    inv <span class="op">=</span> <span class="va">self</span>.inv(partials[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    outputs <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(values)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(values), <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        outputs[i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="va">self</span>.mul(partials[i<span class="op">-</span><span class="dv">1</span>], inv) <span class="cf">if</span> values[i<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        inv <span class="op">=</span> <span class="va">self</span>.mul(inv, values[i<span class="op">-</span><span class="dv">1</span>] <span class="kw">or</span> <span class="dv">1</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> outputs</span></code></pre></div>
<p>This batch inverse algorithm will prove important later on, when we
start dealing with dividing sets of evaluations of polynomials.</p>
<p>Now we move on to some polynomial operations. We treat a polynomial
as an array, where element <span class="math inline">\(i\)</span> is the
<span class="math inline">\(i\)</span>th degree term (eg. <span
class="math inline">\(x^{3} + 2x + 1\)</span> becomes
<code>[1, 2, 0, 1]</code>). Here's the operation of evaluating a
polynomial at <em>one point</em>:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluate a polynomial at a point</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eval_poly_at(<span class="va">self</span>, p, x):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    power_of_x <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, p_coeff <span class="kw">in</span> <span class="bu">enumerate</span>(p):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        y <span class="op">+=</span> power_of_x <span class="op">*</span> p_coeff</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        power_of_x <span class="op">=</span> (power_of_x <span class="op">*</span> x) <span class="op">%</span> <span class="va">self</span>.modulus</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y <span class="op">%</span> <span class="va">self</span>.modulus</span></code></pre></div>
<br>
<blockquote>
<b>Challenge</b><br> What is the output of <code>f.eval_poly_at([4, 5,
6], 2)</code> if the modulus is 31?<br> <br> <b>Mouseover below for
answer</b> <br>
<div class="foo">
<p><span class="math inline">\(6 \cdot 2^{2} + 5 \cdot 2 + 4 = 38, 38
\bmod 31 = 7\)</span>.</p>
</div>
</blockquote>
<p>There is also code for adding, subtracting, multiplying and dividing
polynomials; this is textbook long
addition/subtraction/multiplication/division. The one non-trivial thing
is Lagrange interpolation, which takes as input a set of x and y
coordinates, and returns the minimal polynomial that passes through all
of those points (you can think of it as being the inverse of polynomial
evaluation):</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build a polynomial that returns 0 at all specified xs</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zpoly(<span class="va">self</span>, xs):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> [<span class="dv">1</span>]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> xs:</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        root.insert(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(root)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            root[j] <span class="op">-=</span> root[j<span class="op">+</span><span class="dv">1</span>] <span class="op">*</span> x</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [x <span class="op">%</span> <span class="va">self</span>.modulus <span class="cf">for</span> x <span class="kw">in</span> root]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lagrange_interp(<span class="va">self</span>, xs, ys):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate master numerator polynomial, eg. (x - x1) * (x - x2) * ... * (x - xn)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> <span class="va">self</span>.zpoly(xs)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate per-value numerator polynomials, eg. for x=x2,</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (x - x1) * (x - x3) * ... * (x - xn), by dividing the master</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># polynomial back by each x coordinate</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    nums <span class="op">=</span> [<span class="va">self</span>.div_polys(root, [<span class="op">-</span>x, <span class="dv">1</span>]) <span class="cf">for</span> x <span class="kw">in</span> xs]</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate denominators by evaluating numerator polys at each x</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    denoms <span class="op">=</span> [<span class="va">self</span>.eval_poly_at(nums[i], xs[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(xs))]</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    invdenoms <span class="op">=</span> <span class="va">self</span>.multi_inv(denoms)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate output polynomial, which is the sum of the per-value numerator</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># polynomials rescaled to have the right y values</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> y <span class="kw">in</span> ys]</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(xs)):</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        yslice <span class="op">=</span> <span class="va">self</span>.mul(ys[i], invdenoms[i])</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ys)):</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nums[i][j] <span class="kw">and</span> ys[i]:</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>                b[j] <span class="op">+=</span> nums[i][j] <span class="op">*</span> yslice</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [x <span class="op">%</span> <span class="va">self</span>.modulus <span class="cf">for</span> x <span class="kw">in</span> b]</span></code></pre></div>
<p>See <a
href="https://blog.ethereum.org/2014/08/16/secret-sharing-erasure-coding-guide-aspiring-dropbox-decentralizer/">the
"M of N" section of this article</a> for a description of the math. Note
that we also have special-case methods <code>lagrange_interp_4</code>
and <code>lagrange_interp_2</code> to speed up the very frequent
operations of Lagrange interpolation of degree <span
class="math inline">\(&lt; 2\)</span> and degree <span
class="math inline">\(&lt; 4\)</span> polynomials.</p>
<h3 id="fast-fourier-transforms">Fast Fourier Transforms</h3>
<p>If you read the above algorithms carefully, you might notice that
Lagrange interpolation and multi-point evaluation (that is, evaluating a
degree <span class="math inline">\(&lt; N\)</span> polynomial at <span
class="math inline">\(N\)</span> points) both take quadratic time to
execute, so for example doing a Lagrange interpolation of one thousand
points takes a few million steps to execute, and a Lagrange
interpolation of one million points takes a few trillion. This is an
unacceptably high level of inefficiency, so we will use a more efficient
algorithm, the Fast Fourier Transform.</p>
<p>The FFT only takes <span class="math inline">\(O(n \cdot
log(n))\)</span> time (ie. ~10,000 steps for 1,000 points, ~20 million
steps for 1 million points), though it is more restricted in scope; the
x coordinates must be a complete set of <strong><a
href="https://en.wikipedia.org/wiki/Root_of_unity">roots of
unity</a></strong> of some
<strong><a href="https://en.wikipedia.org/wiki/Order_(group_theory)">order</a></strong>
<span class="math inline">\(N = 2^{k}\)</span>. That is, if there are
<span class="math inline">\(N\)</span> points, the x coordinates must be
successive powers <span class="math inline">\(1, p, p^{2},
p^{3}\)</span>... of some <span class="math inline">\(p\)</span> where
<span class="math inline">\(p^{N} = 1\)</span>. The algorithm can,
surprisingly enough, be used for multi-point evaluation <em>or</em>
interpolation, with one small parameter tweak.</p>
<br>
<blockquote>
<b>Challenge</b> Find a 16th root of unity mod 337 that is not an 8th
root of unity.<br> <br> <b>Mouseover below for answer</b> <br>
<div class="foo">
<p><code style="background-color:white">59, 146, 30, 297, 278, 191, 307,
40</code><br> <br> You could have gotten this list by doing something
like <code style="background-color:white">[print(x) for x in range(337)
if pow(x, 16, 337) == 1 and pow(x, 8, 337) != 1]</code>, though there is
a smarter way that works for much larger moduluses: first, identify a
single <i>primitive root</i> mod 337 (that is, not a perfect square), by
looking for a value <code style="background-color:white">x</code> such
that <code style="background-color:white">pow(x, 336 // 2, 337) !=
1</code> (these are easy to find; one answer is 5), and then taking the
(336 / 16)'th power of it.</p>
</div>
</blockquote>
<p>Here's the algorithm (in a slightly simplified form; see <a
href="https://github.com/ethereum/research/blob/master/mimc_stark/fft.py">code
here</a> for something slightly more optimized):</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fft(vals, modulus, root_of_unity):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(vals) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> vals</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> fft(vals[::<span class="dv">2</span>], modulus, <span class="bu">pow</span>(root_of_unity, <span class="dv">2</span>, modulus))</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> fft(vals[<span class="dv">1</span>::<span class="dv">2</span>], modulus, <span class="bu">pow</span>(root_of_unity, <span class="dv">2</span>, modulus))</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    o <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> vals]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(L, R)):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        y_times_root <span class="op">=</span> y<span class="op">*</span><span class="bu">pow</span>(root_of_unity, i, modulus)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        o[i] <span class="op">=</span> (x<span class="op">+</span>y_times_root) <span class="op">%</span> modulus</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        o[i<span class="op">+</span><span class="bu">len</span>(L)] <span class="op">=</span> (x<span class="op">-</span>y_times_root) <span class="op">%</span> modulus</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> o</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inv_fft(vals, modulus, root_of_unity):</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> PrimeField(modulus)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inverse FFT</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    invlen <span class="op">=</span> f.inv(<span class="bu">len</span>(vals))</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [(x<span class="op">*</span>invlen) <span class="op">%</span> modulus <span class="cf">for</span> x <span class="kw">in</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            fft(vals, modulus, f.inv(root_of_unity))]</span></code></pre></div>
<p>You can try running it on a few inputs yourself and check that it
gives results that, when you use <code>eval_poly_at</code> on them, give
you the answers you expect to get. For example:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> fft.fft([<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">6</span>], <span class="dv">337</span>, <span class="dv">85</span>, inv<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">46</span>, <span class="dv">169</span>, <span class="dv">29</span>, <span class="dv">149</span>, <span class="dv">126</span>, <span class="dv">262</span>, <span class="dv">140</span>, <span class="dv">93</span>]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> f <span class="op">=</span> poly_utils.PrimeField(<span class="dv">337</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> [f.eval_poly_at([<span class="dv">46</span>, <span class="dv">169</span>, <span class="dv">29</span>, <span class="dv">149</span>, <span class="dv">126</span>, <span class="dv">262</span>, <span class="dv">140</span>, <span class="dv">93</span>], f.exp(<span class="dv">85</span>, i)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span>)]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">2</span>, <span class="dv">6</span>]</span></code></pre></div>
<p>A Fourier transform takes as input <code>[x[0] .... x[n-1]]</code>,
and its goal is to output <code>x[0] + x[1] + ... + x[n-1]</code> as the
first element, <code>x[0] + x[1] * 2 + ... + x[n-1] * w**(n-1)</code> as
the second element, etc etc; a fast Fourier transform accomplishes this
by splitting the data in half, doing an FFT on both halves, and then
gluing the result back together.</p>
<center>
<img src="../../../../images/starks-part-3-files/radix2fft.png" class="padded" /><br><br>
<small><i>A diagram of how information flows through the FFT
computation. Notice how the FFT consists of a "gluing" step followed by
two copies of the FFT on two halves of the data, and so on recursively
until you're down to one element.</i></small>
</center>
<p><br></p>
<p>I recommend <a
href="http://web.cecs.pdx.edu/~maier/cs584/Lectures/lect07b-11-MG.pdf">this</a>
for more intuition on how or why the FFT works and polynomial math in
general, and <a
href="https://dsp.stackexchange.com/questions/41558/what-are-some-of-the-differences-between-dft-and-fft-that-make-fft-so-fast?rq=1">this
thread</a> for some more specifics on DFT vs FFT, though be warned that
most literature on Fourier transforms talks about Fourier transforms
over <em>real and complex numbers</em>, not <em>prime fields</em>. If
you find this too hard and don't want to understand it, just treat it as
weird spooky voodoo that just works because you ran the code a few times
and verified that it works, and you'll be fine too.</p>
<h3
id="thank-goodness-its-fri-day-thats-fast-reed-solomon-interactive-oracle-proofs-of-proximity">Thank
Goodness It's FRI-day (that's "Fast Reed-Solomon Interactive Oracle
Proofs of Proximity")</h3>
<p><em><strong>Reminder</strong>: now may be a good time to review and
re-read <a href="../../../2017/11/22/starks_part_2.html">Part
2</a></em></p>
<p>Now, we'll get into <a
href="https://github.com/ethereum/research/blob/master/mimc_stark/fri.py">the
code</a> for making a low-degree proof. To review, a low-degree proof is
a (probabilistic) proof that at least some high percentage (eg. 80%) of
a given set of values represent the evaluations of some specific
polynomial whose degree is much lower than the number of values given.
Intuitively, just think of it as a proof that "some Merkle root that we
claim represents a polynomial actually does represent a polynomial,
possibly with a few errors". As input, we have:</p>
<ul>
<li>A set of values that we claim are the evaluation of a low-degree
polynomial</li>
<li>A root of unity; the x coordinates at which the polynomial is
evaluated are successive powers of this root of unity</li>
<li>A value <span class="math inline">\(N\)</span> such that we are
proving the degree of the polynomial is <em>strictly less than</em>
<span class="math inline">\(N\)</span></li>
<li>The modulus</li>
</ul>
<p>Our approach is a recursive one, with two cases. First, if the degree
is low enough, we just provide the entire list of values as a proof;
this is the "base case". Verification of the base case is trivial: do an
FFT or Lagrange interpolation or whatever else to interpolate the
polynomial representing those values, and verify that its degree is
<span class="math inline">\(&lt; N\)</span>. Otherwise, if the degree is
higher than some set minimum, we do the vertical-and-diagonal trick
described <a href="../../../2017/11/22/starks_part_2.html">at the bottom
of Part 2</a>.</p>
<p>We start off by putting the values into a Merkle tree and using the
Merkle root to select a pseudo-random x coordinate
(<code>special_x</code>). We then calculate the "column":</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the set of x coordinates</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>xs <span class="op">=</span> get_power_cycle(root_of_unity, modulus)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>column <span class="op">=</span> []</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(xs)<span class="op">//</span><span class="dv">4</span>):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    x_poly <span class="op">=</span> f.lagrange_interp_4(</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        [xs[i<span class="op">+</span><span class="bu">len</span>(xs)<span class="op">*</span>j<span class="op">//</span><span class="dv">4</span>] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)],</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        [values[i<span class="op">+</span><span class="bu">len</span>(values)<span class="op">*</span>j<span class="op">//</span><span class="dv">4</span>] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)],</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    column.append(f.eval_poly_at(x_poly, special_x))</span></code></pre></div>
<p>This packs a lot into a few lines of code. The broad idea is to
re-interpret the polynomial <span class="math inline">\(P(x)\)</span> as
a polynomial <span class="math inline">\(Q(x, y)\)</span>, where <span
class="math inline">\(P(x) = Q(x, x^4)\)</span>. If <span
class="math inline">\(P\)</span> has degree <span
class="math inline">\(&lt; N\)</span>, then <span
class="math inline">\(P&#39;(y) = Q(special\_x, y)\)</span> will have
degree <span class="math inline">\(&lt; \frac{N}{4}\)</span>. Since we
don't want to take the effort to actually compute <span
class="math inline">\(Q\)</span> in coefficient form (that would take a
still-relatively-nasty-and-expensive FFT!), we instead use another
trick. For any given value of <span
class="math inline">\(x^{4}\)</span>, there are 4 corresponding values
of <span class="math inline">\(x\)</span>: <span
class="math inline">\(x\)</span>, <span class="math inline">\(modulus -
x\)</span>, and <span class="math inline">\(x\)</span> multiplied by the
two modular square roots of <span class="math inline">\(-1\)</span>. So
we already have four values of <span class="math inline">\(Q(?,
x^4)\)</span>, which we can use to interpolate the polynomial <span
class="math inline">\(R(x) = Q(x, x^4)\)</span>, and from there
calculate <span class="math inline">\(R(special\_x) = Q(special\_x, x^4)
= P&#39;(x^4)\)</span>. There are <span
class="math inline">\(\frac{N}{4}\)</span> possible values of <span
class="math inline">\(x^{4}\)</span>, and this lets us easily calculate
all of them.</p>
<center>
<img src="../../../../images/starks-part-3-files/fri7.png" style="width:550px" class="padded" /><br><br>
<small><i>A diagram from part 2; it helps to keep this in mind when
understanding what's going on here</i></small>
</center>
<p><br></p>
<p>Our proof consists of some number (eg. 40) of random queries from the
list of values of <span class="math inline">\(x^{4}\)</span> (using the
Merkle root of the column as a seed), and for each query we provide
Merkle branches of the five values of <span class="math inline">\(Q(?,
x^4)\)</span>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>m2 <span class="op">=</span> merkelize(column)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Pseudo-randomly select y indices to sample</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># (m2[1] is the Merkle root of the column)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>ys <span class="op">=</span> get_pseudorandom_indices(m2[<span class="dv">1</span>], <span class="bu">len</span>(column), <span class="dv">40</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the Merkle branches for the values in the polynomial and the column</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>branches <span class="op">=</span> []</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> ys:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    branches.append([mk_branch(m2, y)] <span class="op">+</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>                    [mk_branch(m, y <span class="op">+</span> (<span class="bu">len</span>(xs) <span class="op">//</span> <span class="dv">4</span>) <span class="op">*</span> j) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)])</span></code></pre></div>
<p>The verifier's job will be to verify that these five values actually
do lie on the same degree <span class="math inline">\(&lt; 4\)</span>
polynomial. From there, we recurse and do an FRI on the column,
verifying that the column actually does have degree <span
class="math inline">\(&lt; \frac{N}{4}\)</span>. That really is all
there is to FRI.</p>
<p>As a challenge exercise, you could try creating low-degree proofs of
polynomial evaluations that have errors in them, and see how many errors
you can get away passing the verifier with (hint, you'll need to modify
the <code>prove_low_degree</code> function; with the default prover,
even one error will balloon up and cause verification to fail).</p>
<h3 id="the-stark">The STARK</h3>
<p><em><strong>Reminder</strong>: now may be a good time to review and
re-read <a href="../../../2017/11/09/starks_part_1.html">Part
1</a></em></p>
<p>Now, we get to the actual meat that puts all of these pieces
together: <code>def mk_mimc_proof(inp, steps, round_constants)</code>
(code <a
href="https://github.com/ethereum/research/blob/master/mimc_stark/mimc_stark.py">here</a>),
which generates a proof of the execution result of running the MIMC
function with the given input for some number of steps. First, some
asserts:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> steps <span class="op">&lt;=</span> <span class="dv">2</span><span class="op">**</span><span class="dv">32</span> <span class="op">//</span> extension_factor</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> is_a_power_of_2(steps) <span class="kw">and</span> is_a_power_of_2(<span class="bu">len</span>(round_constants))</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">len</span>(round_constants) <span class="op">&lt;</span> steps</span></code></pre></div>
<p>The extension factor is the extent to which we will be "stretching"
the computational trace (the set of "intermediate values" of executing
the MIMC function). We need the step count multiplied by the extension
factor to be at most <span class="math inline">\(2^{32}\)</span>,
because we don't have roots of unity of order <span
class="math inline">\(2^{k}\)</span> for <span class="math inline">\(k
&gt; 32\)</span>.</p>
<p>Our first computation will be to generate the computational trace;
that is, all of the <em>intermediate</em> values of the computation,
from the input going all the way to the output.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate the computational trace</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>computational_trace <span class="op">=</span> [inp]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(steps<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    computational_trace.append((computational_trace[<span class="op">-</span><span class="dv">1</span>]<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> round_constants[i <span class="op">%</span> <span class="bu">len</span>(round_constants)]) <span class="op">%</span> modulus)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> computational_trace[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<p>We then convert the computation trace into a polynomial, "laying
down" successive values in the trace on successive powers of a root of
unity <span class="math inline">\(g\)</span> where <span
class="math inline">\(g^{steps}\)</span> = 1, and we then evaluate the
polynomial in a larger set, of successive powers of a root of unity
<span class="math inline">\(g_2\)</span> where <span
class="math inline">\((g_2)^{steps \cdot 8} = 1\)</span> (note that
<span class="math inline">\((g_2)^{8} = g\)</span>).</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>computational_trace_polynomial <span class="op">=</span> inv_fft(computational_trace, modulus, subroot)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>p_evaluations <span class="op">=</span> fft(computational_trace_polynomial, modulus, root_of_unity)</span></code></pre></div>
<center>
<img src="../../../../images/starks-part-3-files/RootsOfUnity.png" /><br><br>
<small><i>Black: powers of <span class="math inline">\(g_1\)</span>.
Purple: powers of <span class="math inline">\(g_2\)</span>. Orange: 1.
You can look at successive roots of unity as being arranged in a circle
in this way. We are "laying" the computational trace along powers of
<span class="math inline">\(g_1\)</span>, and then extending it compute
the values of the same polynomial at the intermediate values (ie. the
powers of <span class="math inline">\(g_2\)</span>).</i></small>
</center>
<p><br></p>
<p>We can convert the round constants of MIMC into a polynomial. Because
these round constants loop around very frequently (in our tests, every
64 steps), it turns out that they form a degree-64 polynomial, and we
can fairly easily compute its expression, and its extension:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>skips2 <span class="op">=</span> steps <span class="op">//</span> <span class="bu">len</span>(round_constants)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>constants_mini_polynomial <span class="op">=</span> fft(round_constants, modulus, f.exp(subroot, skips2), inv<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>constants_polynomial <span class="op">=</span> [<span class="dv">0</span> <span class="cf">if</span> i <span class="op">%</span> skips2 <span class="cf">else</span> constants_mini_polynomial[i<span class="op">//</span>skips2] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(steps)]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>constants_mini_extension <span class="op">=</span> fft(constants_mini_polynomial, modulus, f.exp(root_of_unity, skips2))</span></code></pre></div>
<p>Suppose there are 8192 steps of execution and 64 round constants.
Here is what we are doing: we are doing an FFT to compute the round
constants <i>as a function of <span
class="math inline">\((g_1)^{128}\)</span></i>. We then add zeroes in
between the constants to make it a function of <span
class="math inline">\(g_1\)</span> itself. Because <span
class="math inline">\((g_1)^{128}\)</span> loops around every 64 steps,
we know this function of <span class="math inline">\(g_1\)</span> will
as well. We only compute 512 steps of the extension, because we know
that the extension repeats after 512 steps as well.</p>
<p>We now, as in the Fibonacci example in Part 1, calculate <span
class="math inline">\(C(P(x))\)</span>, except this time it's <span
class="math inline">\(C(P(x), P(g_1 \cdot x), K(x))\)</span>:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the composed polynomial such that</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co"># C(P(x), P(g1*x), K(x)) = P(g1*x) - P(x)**3 - K(x)</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>c_of_p_evaluations <span class="op">=</span> [(p_evaluations[(i<span class="op">+</span>extension_factor)<span class="op">%</span>precision] <span class="op">-</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                          f.exp(p_evaluations[i], <span class="dv">3</span>) <span class="op">-</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                          constants_mini_extension[i <span class="op">%</span> <span class="bu">len</span>(constants_mini_extension)])</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>                      <span class="op">%</span> modulus <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(precision)]</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;Computed C(P, K) polynomial&#39;</span>)</span></code></pre></div>
<p>Note that here we are no longer working with polynomials in
<em>coefficient form</em>; we are working with the polynomials in terms
of their evaluations at successive powers of the higher-order root of
unity.</p>
<p><code>c_of_p</code> is intended to be <span
class="math inline">\(Q(x) = C(P(x), P(g_1 \cdot x), K(x)) = P(g_1 \cdot
x) - P(x)^3 - K(x)\)</span>; the goal is that for every <span
class="math inline">\(x\)</span> that we are laying the computational
trace along (except for the last step, as there's no step "after" the
last step), the next value in the trace is equal to the previous value
in the trace cubed, plus the round constant. Unlike the Fibonacci
example in Part 1, where if one computational step was at coordinate
<span class="math inline">\(k\)</span>, the next step is at coordinate
<span class="math inline">\(k+1\)</span>, here we are laying down the
computational trace along successive powers of the lower-order root of
unity <span class="math inline">\(g_1\)</span>, so if one computational
step is located at <span class="math inline">\(x = (g_1)^i\)</span>, the
"next" step is located at <span
class="math inline">\((g_1)^{i+1}\)</span> = <span
class="math inline">\((g_1)^i \cdot g_1 = x \cdot g_1\)</span>. Hence,
for every power of the lower-order root of unity <span
class="math inline">\(g_1\)</span> (except the last), we want it to be
the case that <span class="math inline">\(P(x\cdot g_1) = P(x)^3 +
K(x)\)</span>, or <span class="math inline">\(P(x\cdot g_1) - P(x)^3 -
K(x) = Q(x) = 0\)</span>. Thus, <span
class="math inline">\(Q(x)\)</span> will be equal to zero at all
successive powers of the lower-order root of unity <span
class="math inline">\(g\)</span> (except the last).</p>
<p>There is an algebraic theorem that proves that if <span
class="math inline">\(Q(x)\)</span> is equal to zero at all of these x
coordinates, then it is a multiple of the <em>minimal</em> polynomial
that is equal to zero at all of these x coordinates: <span
class="math inline">\(Z(x) = (x - x_1) \cdot (x - x_2) \cdot ... \cdot
(x - x_n)\)</span>. Since proving that <span
class="math inline">\(Q(x)\)</span> is equal to zero at every single
coordinate we want to check is too hard (as verifying such a proof would
take longer than just running the original computation!), instead we use
an indirect approach to (probabilistically) prove that <span
class="math inline">\(Q(x)\)</span> is a multiple of <span
class="math inline">\(Z(x)\)</span>. And how do we do that? By providing
the quotient <span class="math inline">\(D(x) =
\frac{Q(x)}{Z(x)}\)</span> and using FRI to prove that it's an actual
polynomial and not a fraction, of course!</p>
<p>We chose the particular arrangement of lower and higher order roots
of unity (rather than, say, laying the computational trace along the
first few powers of the higher order root of unity) because it turns out
that computing <span class="math inline">\(Z(x)\)</span> (the polynomial
that evaluates to zero at all points along the computational trace
except the last), and dividing by <span
class="math inline">\(Z(x)\)</span> is trivial there: the expression of
<span class="math inline">\(Z\)</span> is a fraction of two terms.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute D(x) = Q(x) / Z(x)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Z(x) = (x^steps - 1) / (x - x_atlast_step)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>z_num_evaluations <span class="op">=</span> [xs[(i <span class="op">*</span> steps) <span class="op">%</span> precision] <span class="op">-</span> <span class="dv">1</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(precision)]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>z_num_inv <span class="op">=</span> f.multi_inv(z_num_evaluations)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>z_den_evaluations <span class="op">=</span> [xs[i] <span class="op">-</span> last_step_position <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(precision)]</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>d_evaluations <span class="op">=</span> [cp <span class="op">*</span> zd <span class="op">*</span> zni <span class="op">%</span> modulus <span class="cf">for</span> cp, zd, zni <span class="kw">in</span> <span class="bu">zip</span>(c_of_p_evaluations, z_den_evaluations, z_num_inv)]</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;Computed D polynomial&#39;</span>)</span></code></pre></div>
<p>Notice that we compute the numerator and denominator of <span
class="math inline">\(Z\)</span> directly in "evaluation form", and then
use the batch modular inversion to turn dividing by <span
class="math inline">\(Z\)</span> into a multiplication (<span
class="math inline">\(\cdot z_d \cdot z_ni\)</span>), and then pointwise
multiply the evaluations of <span class="math inline">\(Q(x)\)</span> by
these inverses of <span class="math inline">\(Z(x)\)</span>. Note that
at the powers of the lower-order root of unity except the last (ie.
along the portion of the low-degree extension that is part of the
original computational trace), <span class="math inline">\(Z(x) =
0\)</span>, so this computation involving its inverse will break. This
is unfortunate, though we will plug the hole by simply modifying the
random checks and FRI algorithm to not sample at those points, so the
fact that we calculated them wrong will never matter.</p>
<p>Because <span class="math inline">\(Z(x)\)</span> can be expressed so
compactly, we get another benefit: the verifier can compute <span
class="math inline">\(Z(x)\)</span> for any specific <span
class="math inline">\(x\)</span> extremely quickly, without needing any
precomputation. It's okay for the <em>prover</em> to have to deal with
polynomials whose size equals the number of steps, but we don't want to
ask the <em>verifier</em> to do the same, as we want verification to be
succinct (ie. ultra-fast, with proofs as small as possible).</p>
<p>Probabilistically checking <span class="math inline">\(D(x) \cdot
Z(x) = Q(x)\)</span> at a few randomly selected points allows us to
verify the <strong>transition constraints</strong> - that each
computational step is a valid consequence of the previous step. But we
also want to verify the <strong>boundary constraints</strong> - that the
input and the output of the computation is what the prover says they
are. Just asking the prover to provide evaluations of <span
class="math inline">\(P(1)\)</span>, <span
class="math inline">\(D(1)\)</span>, <span
class="math inline">\(P(last\_step)\)</span> and <span
class="math inline">\(D(last\_step)\)</span> (where <span
class="math inline">\(last\_step\)</span> (or <span
class="math inline">\(g^{steps-1}\)</span>) is the coordinate
corresponding to the last step in the computation) is too fragile;
there's no proof that those values are on the same polynomial as the
rest of the data. So instead we use a similar kind of polynomial
division trick:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute interpolant of ((1, input), (x_atlast_step, output))</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>interpolant <span class="op">=</span> f.lagrange_interp_2([<span class="dv">1</span>, last_step_position], [inp, output])</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>i_evaluations <span class="op">=</span> [f.eval_poly_at(interpolant, x) <span class="cf">for</span> x <span class="kw">in</span> xs]</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>zeropoly2 <span class="op">=</span> f.mul_polys([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>], [<span class="op">-</span>last_step_position, <span class="dv">1</span>])</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>inv_z2_evaluations <span class="op">=</span> f.multi_inv([f.eval_poly_at(quotient, x) <span class="cf">for</span> x <span class="kw">in</span> xs])</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co"># B = (P - I) / Z2</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>b_evaluations <span class="op">=</span> [((p <span class="op">-</span> i) <span class="op">*</span> invq) <span class="op">%</span> modulus <span class="cf">for</span> p, i, invq <span class="kw">in</span> <span class="bu">zip</span>(p_evaluations, i_evaluations, inv_z2_evaluations)]</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;Computed B polynomial&#39;</span>)</span></code></pre></div>
<p>The argument is as follows. The prover wants to prove <span
class="math inline">\(P(1) = input\)</span> and <span
class="math inline">\(P(last\_step) = output\)</span>. If we take <span
class="math inline">\(I(x)\)</span> as the <em>interpolant</em> - the
line that crosses the two points <span class="math inline">\((1,
input)\)</span> and <span class="math inline">\((last\_step,
output)\)</span>, then <span class="math inline">\(P(x) - I(x)\)</span>
would be equal to zero at those two points. Thus, it suffices to prove
that <span class="math inline">\(P(x) - I(x)\)</span> is a multiple of
<span class="math inline">\((x - 1) \cdot (x - last\_step)\)</span>, and
we do that by... providing the quotient!</p>
<center>
<img src="../../../../images/starks-part-3-files/P_I_and_B.png" /><img src="../../../../images/starks-part-3-files/P_I_and_B_2.png" /><br><br>
<small><i>Purple: computational trace polynomial (P). Green: interpolant
(I) (notice how the interpolant is constructed to equal the input (which
should be the first step of the computational trace) at x=1 and the
output (which should be the last step of the computational trace) at
<span class="math inline">\(x=g^{steps-1}\)</span>. Red: <span
class="math inline">\(P - I\)</span>. Yellow: the minimal polynomial
that equals <span class="math inline">\(0\)</span> at <span
class="math inline">\(x=1\)</span> and <span
class="math inline">\(x=g^{steps-1}\)</span> (that is, <span
class="math inline">\(Z_2\)</span>). Pink: <span
class="math inline">\(\frac{P - I}{Z_2}\)</span>.</i></small>
</center>
<p><br></p>
<br>
<blockquote>
<b>Challenge</b> Suppose you wanted to <i>also</i> prove that the value
in the computational trace after the 703rd computational step is equal
to 8018284612598740. How would you modify the above algorithm to do
that? <br> <b>Mouseover below for answer</b> <br>
<div class="foo">
<p>Set <span class="math inline">\(I(x)\)</span> to be the interpolant
of <span class="math inline">\((1, input), (g^{703}, 8018284612598740),
(last\_step, output)\)</span>, and make a proof by providing the
quotient <span class="math inline">\(B(x) = \frac{P(x) - I(x)}{(x - 1)
\cdot (x - g^{703}) \cdot (x - last\_step)}\)</span> <br></p>
</div>
</blockquote>
<p>Now, we commit to the Merkle root of <span
class="math inline">\(P\)</span>, <span class="math inline">\(D\)</span>
and <span class="math inline">\(B\)</span> combined together.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute their Merkle roots</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>mtree <span class="op">=</span> merkelize([pval.to_bytes(<span class="dv">32</span>, <span class="st">&#39;big&#39;</span>) <span class="op">+</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                   dval.to_bytes(<span class="dv">32</span>, <span class="st">&#39;big&#39;</span>) <span class="op">+</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                   bval.to_bytes(<span class="dv">32</span>, <span class="st">&#39;big&#39;</span>) <span class="cf">for</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>                   pval, dval, bval <span class="kw">in</span> <span class="bu">zip</span>(p_evaluations, d_evaluations, b_evaluations)])</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;Computed hash root&#39;</span>)</span></code></pre></div>
<p>Now, we need to prove that <span class="math inline">\(P\)</span>,
<span class="math inline">\(D\)</span> and <span
class="math inline">\(B\)</span> are all actually polynomials, and of
the right max-degree. But FRI proofs are big and expensive, and we don't
want to have three FRI proofs. So instead, we compute a pseudorandom
linear combination of <span class="math inline">\(P\)</span>, <span
class="math inline">\(D\)</span> and <span
class="math inline">\(B\)</span> (using the Merkle root of <span
class="math inline">\(P\)</span>, <span class="math inline">\(D\)</span>
and <span class="math inline">\(B\)</span> as a seed), and do an FRI
proof on that:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>k1 <span class="op">=</span> <span class="bu">int</span>.from_bytes(blake(mtree[<span class="dv">1</span>] <span class="op">+</span> <span class="st">b&#39;</span><span class="ch">\x01</span><span class="st">&#39;</span>), <span class="st">&#39;big&#39;</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>k2 <span class="op">=</span> <span class="bu">int</span>.from_bytes(blake(mtree[<span class="dv">1</span>] <span class="op">+</span> <span class="st">b&#39;</span><span class="ch">\x02</span><span class="st">&#39;</span>), <span class="st">&#39;big&#39;</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>k3 <span class="op">=</span> <span class="bu">int</span>.from_bytes(blake(mtree[<span class="dv">1</span>] <span class="op">+</span> <span class="st">b&#39;</span><span class="ch">\x03</span><span class="st">&#39;</span>), <span class="st">&#39;big&#39;</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>k4 <span class="op">=</span> <span class="bu">int</span>.from_bytes(blake(mtree[<span class="dv">1</span>] <span class="op">+</span> <span class="st">b&#39;</span><span class="ch">\x04</span><span class="st">&#39;</span>), <span class="st">&#39;big&#39;</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the linear combination. We don&#39;t even bother calculating it</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># in coefficient form; we just compute the evaluations</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>root_of_unity_to_the_steps <span class="op">=</span> f.exp(root_of_unity, steps)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>powers <span class="op">=</span> [<span class="dv">1</span>]</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, precision):</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    powers.append(powers[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> root_of_unity_to_the_steps <span class="op">%</span> modulus)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>l_evaluations <span class="op">=</span> [(d_evaluations[i] <span class="op">+</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>                  p_evaluations[i] <span class="op">*</span> k1 <span class="op">+</span> p_evaluations[i] <span class="op">*</span> k2 <span class="op">*</span> powers[i] <span class="op">+</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>                  b_evaluations[i] <span class="op">*</span> k3 <span class="op">+</span> b_evaluations[i] <span class="op">*</span> powers[i] <span class="op">*</span> k4) <span class="op">%</span> modulus</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>                  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(precision)]</span></code></pre></div>
<p>Unless all three of the polynomials have the right low degree, it's
almost impossible that a randomly selected linear combination of them
will (you have to get <em>extremely</em> lucky for the terms to cancel),
so this is sufficient.</p>
<p>We want to prove that the degree of D is less than <span
class="math inline">\(2 \cdot steps\)</span>, and that of <span
class="math inline">\(P\)</span> and <span
class="math inline">\(B\)</span> are less than <span
class="math inline">\(steps\)</span>, so we actually make a random
linear combination of <span class="math inline">\(P\)</span>, <span
class="math inline">\(P \cdot x^{steps}\)</span>, <span
class="math inline">\(B\)</span>, <span
class="math inline">\(B^{steps}\)</span> and <span
class="math inline">\(D\)</span>, and check that the degree of this
combination is less than <span class="math inline">\(2 \cdot
steps\)</span>.</p>
<p>Now, we do some spot checks of all of the polynomials. We generate
some random indices, and provide the Merkle branches of the polynomial
evaluated at those indices:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Do some spot checks of the Merkle tree at pseudo-random coordinates, excluding</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"># multiples of `extension_factor`</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>branches <span class="op">=</span> []</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> spot_check_security_factor</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> get_pseudorandom_indices(l_mtree[<span class="dv">1</span>], precision, samples,</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>                                     exclude_multiples_of<span class="op">=</span>extension_factor)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> pos <span class="kw">in</span> positions:</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    branches.append(mk_branch(mtree, pos))</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    branches.append(mk_branch(mtree, (pos <span class="op">+</span> skips) <span class="op">%</span> precision))</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    branches.append(mk_branch(l_mtree, pos))</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;Computed </span><span class="sc">%d</span><span class="st"> spot checks&#39;</span> <span class="op">%</span> samples)</span></code></pre></div>
<p>The <code>get_pseudorandom_indices</code> function returns some
random indices in the range [0...precision-1], and the
<code>exclude_multiples_of</code> parameter tells it to not give values
that are multiples of the given parameter (here,
<code>extension_factor</code>). This ensures that we do not sample along
the original computational trace, where we are likely to get wrong
answers.</p>
<p>The proof (~250-500 kilobytes altogether) consists of a set of Merkle
roots, the spot-checked branches, and a low-degree proof of the random
linear combination:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>o <span class="op">=</span> [mtree[<span class="dv">1</span>],</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>     l_mtree[<span class="dv">1</span>],</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>     branches,</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>     prove_low_degree(l_evaluations, root_of_unity, steps <span class="op">*</span> <span class="dv">2</span>, modulus, exclude_multiples_of<span class="op">=</span>extension_factor)]</span></code></pre></div>
<p>The largest parts of the proof in practice are the Merkle branches,
and the FRI proof, which consists of even more branches. And here's the
"meat" of the verifier:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, pos <span class="kw">in</span> <span class="bu">enumerate</span>(positions):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> f.exp(G2, pos)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    x_to_the_steps <span class="op">=</span> f.exp(x, steps)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    mbranch1 <span class="op">=</span>  verify_branch(m_root, pos, branches[i<span class="op">*</span><span class="dv">3</span>])</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    mbranch2 <span class="op">=</span>  verify_branch(m_root, (pos<span class="op">+</span>skips)<span class="op">%</span>precision, branches[i<span class="op">*</span><span class="dv">3</span><span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    l_of_x <span class="op">=</span> verify_branch(l_root, pos, branches[i<span class="op">*</span><span class="dv">3</span> <span class="op">+</span> <span class="dv">2</span>], output_as_int<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    p_of_x <span class="op">=</span> <span class="bu">int</span>.from_bytes(mbranch1[:<span class="dv">32</span>], <span class="st">&#39;big&#39;</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    p_of_g1x <span class="op">=</span> <span class="bu">int</span>.from_bytes(mbranch2[:<span class="dv">32</span>], <span class="st">&#39;big&#39;</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    d_of_x <span class="op">=</span> <span class="bu">int</span>.from_bytes(mbranch1[<span class="dv">32</span>:<span class="dv">64</span>], <span class="st">&#39;big&#39;</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    b_of_x <span class="op">=</span> <span class="bu">int</span>.from_bytes(mbranch1[<span class="dv">64</span>:], <span class="st">&#39;big&#39;</span>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    zvalue <span class="op">=</span> f.div(f.exp(x, steps) <span class="op">-</span> <span class="dv">1</span>,</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>                   x <span class="op">-</span> last_step_position)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    k_of_x <span class="op">=</span> f.eval_poly_at(constants_mini_polynomial, f.exp(x, skips2))</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check transition constraints Q(x) = Z(x) * D(x)</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> (p_of_g1x <span class="op">-</span> p_of_x <span class="op">**</span> <span class="dv">3</span> <span class="op">-</span> k_of_x <span class="op">-</span> zvalue <span class="op">*</span> d_of_x) <span class="op">%</span> modulus <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check boundary constraints B(x) * Z2(x) + I(x) = P(x)</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    interpolant <span class="op">=</span> f.lagrange_interp_2([<span class="dv">1</span>, last_step_position], [inp, output])</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    zeropoly2 <span class="op">=</span> f.mul_polys([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>], [<span class="op">-</span>last_step_position, <span class="dv">1</span>])</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> (p_of_x <span class="op">-</span> b_of_x <span class="op">*</span> f.eval_poly_at(zeropoly2, x) <span class="op">-</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>            f.eval_poly_at(interpolant, x)) <span class="op">%</span> modulus <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check correctness of the linear combination</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> (l_of_x <span class="op">-</span> d_of_x <span class="op">-</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>            k1 <span class="op">*</span> p_of_x <span class="op">-</span> k2 <span class="op">*</span> p_of_x <span class="op">*</span> x_to_the_steps <span class="op">-</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>            k3 <span class="op">*</span> b_of_x <span class="op">-</span> k4 <span class="op">*</span> b_of_x <span class="op">*</span> x_to_the_steps) <span class="op">%</span> modulus <span class="op">==</span> <span class="dv">0</span></span></code></pre></div>
<p>At every one of the positions that the prover provides a Merkle proof
for, the verifier checks the Merkle proof, and checks that <span
class="math inline">\(C(P(x), P(g_1 \cdot x), K(x)) = Z(x) \cdot
D(x)\)</span> and <span class="math inline">\(B(x) \cdot Z_2(x) + I(x) =
P(x)\)</span> (reminder: for <span class="math inline">\(x\)</span> that
are not along the original computation trace, <span
class="math inline">\(Z(x)\)</span> will not be zero, and so <span
class="math inline">\(C(P(x), P(g_1 \cdot x), K(x))\)</span> likely will
not evaluate to zero). The verifier also checks that the linear
combination is correct, and calls
<code>verify_low_degree_proof(l_root, root_of_unity, fri_proof, steps * 2, modulus, exclude_multiples_of=extension_factor)</code>
to verify the FRI proof. <strong>And we're done</strong>!</p>
<p>Well, not really; soundness analysis to prove how many spot-checks
for the cross-polynomial checking and for the FRI are necessary is
really tricky. But that's all there is to the code, at least if you
don't care about making even crazier optimizations. When I run the code
above, we get a STARK proving "overhead" of about 300-400x (eg. a MIMC
computation that takes 0.2 seconds to calculate takes 60 second to
prove), suggesting that with a 4-core machine computing the STARK of the
MIMC computation in the forward direction could actually be faster than
computing MIMC in the backward direction. That said, these are both
relatively inefficient implementations in python, and the proving to
running time ratio for properly optimized implementations may be
different. Also, it's worth pointing out that the STARK proving overhead
for MIMC is remarkably low, because MIMC is almost perfectly
"arithmetizable" - it's mathematical form is very simple. For "average"
computations, which contain less arithmetically clean operations (eg.
checking if a number is greater or less than another number), the
overhead is likely much higher, possibly around 10000-50000x.</p>
 </div> 